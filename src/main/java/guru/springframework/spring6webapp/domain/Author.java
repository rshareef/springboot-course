package guru.springframework.spring6webapp.domain;

import jakarta.persistence.*;

import java.util.Objects;
import java.util.Set;

// using Jakarta Persistence - this is what is telling JPA that 'Author' is going to be an entity (object that exists) persisted to the database.
// Jakarta Persistence.
@Entity
public class Author {
    @Id
    // saying that the ID will get generated by the database.
    @GeneratedValue(strategy = GenerationType.AUTO)
    // declare instance data fields.
    private Long id;
    private String firstName;
    private String lastName;


    // (Step 3) setting up the JPA Mapping.
    @ManyToMany (mappedBy = "authors")

    // (Step 2) set up relationship between entities.
    // declare instance of Set data structure to contain data type 'Book' objects, with reference to the 'Set' object assigned to 'books'.
    private Set<Book> books;
    // getter and setter method for 'books' set.
    public Set<Book> getBooks() {
        return books;
    }
    public void setBooks(Set<Book> books) {
        this.books = books;
    }


    // use IntelliJ to generate Getters and Setters for all of these values.
    // private values, so we need getters and setters for each.
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    // Overriding the default print method.
    @Override
    public String toString() {
        return "Author{" +
                "id=" + id +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", books=" + books +
                '}';
    }

    // Generated equals and hashcode() override methods [to determine if 'Author' instances/entities are equal].
    /* IMPORTANT: Contract Between equals and hashCode:
    When you override the equals method, you must also override hashCode.
    The contract states that if two objects are considered equal via the equals method, they must return the same hash code. This is called the 'Hash code contract'.
    ***Overriding both methods ensures that: your custom objects work correctly with Java collections, maintain data integrity, and define logical equality in a way meaningful to the application.*/

    // Override of 'equals()' method provided in the java Object class, so that different Author object instances that have been created, but are identical? can be recognised as equal by the program?
    @Override
    public boolean equals(Object o) {
        // 1. SELF EQUALITY CHECK: if the memory reference pointed to by: the object which invoked the function (this) AND, the object o (passed into the function as an argument) - are the same:
        // returns true (objects are equal!), and the method is exited (as a boolean value has now been returned).
        if (this == o) return true;
        //------------------------------------------------------- OR

        // 2. IN THE CASE THAT SELF EQUALITY CHECK FAILED: perform type check and null check.
        // if object o is null (and or) the objects are not of type 'Author', return false (objects are not equal), and the method is exited (as a boolean value has now been returned).
        if (o == null || getClass() != o.getClass()) return false;
        /*
        If the above check does not return false, we proceed to the TYPE CASTING STAGE.
        The check above was essential as if the object 'o' passed in was null or of a different class,
        we would get a 'ClassCastException' in the next stage for trying to cast the object 'o' as an 'Author' type
        (because we would be trying cast an object to a type, that is not compatible with its actual class type).
        */

        //--------------- IF ABOVE 'IF STATEMENT' DOESNT RETURN FALSE:

        // 3. TYPECASTING: explicitly cast 'o' which is of type 'Object' to of type 'Author', so we may treat it as an Author object, and access methods and attributes associated with the 'Author' class.
        // This is Downcasting (which is explicit casting unlike Upcasting) an object from type 'Object' to type 'Author'.
        Author author = (Author) o;

        // 4. FINAL CHECK: check
        return Objects.equals(id, author.id);
    }

    // method to call the existing hashCode() method from the java Object class, on the id field, of the instance the hashcode method is invoked on.
    // benefits of using the preexisting method within the override: safely handles any null values, automatically returning 0 in that case. This prevents NullPointerExceptions from occuring when calculating the hashcode value.
    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
}
